# SonarQube-Analyse: github_dijkstra.py

## Zusammenfassung
Diese Datei enthält eine detaillierte Analyse des `github_dijkstra.py`-Codes nach SonarQube-Standards und Regeln. Die Analyse identifiziert Probleme in den Kategorien Code Smells, Bugs und potenzielle Sicherheitsprobleme.

## Identifizierte Probleme

### Code Smells (14 Probleme)

#### Kritisch (3)

1. **Übermäßige zyklomatische Komplexität** 
   - **Pfad**: `dijkstra_naive()`
   - **Beschreibung**: Die Funktion hat eine zyklomatische Komplexität von 14, was weit über dem empfohlenen Maximum von 10 liegt.
   - **Empfehlung**: Die Funktion in kleinere, spezifischere Funktionen aufteilen.

2. **Verwendung von `print()` Anweisungen in Geschäftslogik** 
   - **Pfad**: `dijkstra_naive()` (Zeilen 53, 65)
   - **Beschreibung**: Debugging-Ausgaben sollten nicht in Algorithmen enthalten sein.
   - **Empfehlung**: Ein Logger-System verwenden statt direkter `print()` Anweisungen.

3. **Duplizierte Validierungslogik** 
   - **Pfad**: `shortest_path()` und `dijkstra_naive()`
   - **Beschreibung**: Die Validierung mit `_validate_start_end()` wird an mehreren Stellen aufgerufen.
   - **Empfehlung**: Validierung sollte nur an der API-Grenze (`shortest_path()`) erfolgen.

#### Stark (5)

4. **Ineffiziente Prioritätswarteschlange** 
   - **Pfad**: `dijkstra_naive()` (Zeilen 46-50)
   - **Beschreibung**: Manuelle Implementierung einer Prioritätswarteschlange mittels Liste und linearer Suche.
   - **Empfehlung**: Das `heapq`-Modul aus der Standardbibliothek verwenden.

5. **Redundante Knotenvalidierung** 
   - **Pfad**: `dijkstra_naive()` (Zeile 64-67)
   - **Beschreibung**: Der Check `if u not in g.adj:` ist redundant, da Knoten beim Hinzufügen in die Queue bereits geprüft werden.
   - **Empfehlung**: Diesen redundanten Check entfernen.

6. **Unnötige Bool-Dictionary-Initialisierung** 
   - **Pfad**: `dijkstra_naive()` (Zeile 41)
   - **Beschreibung**: `visited` könnte effizienter als Set implementiert werden.
   - **Empfehlung**: `visited = set()` statt `visited: Dict[Any, bool] = {u: False for u in g.adj}` verwenden.

7. **Übermäßige Kommentare** 
   - **Pfad**: Mehrere Stellen im Code
   - **Beschreibung**: Kommentare wie `# (smell)` oder `# (duplication)` sollten nicht im Produktionscode stehen.
   - **Empfehlung**: Clean Code-Prinzipien anwenden statt Probleme zu kommentieren.

8. **Unspezifischer Typparameter `Any`** 
   - **Pfad**: Gesamter Code
   - **Beschreibung**: Übermäßige Verwendung von `Any` reduziert die Typ-Sicherheit.
   - **Empfehlung**: Generics (`TypeVar`) für die `Graph`-Klasse verwenden.

#### Mittel (4)

9. **Fehlende Docstrings** 
   - **Pfad**: Mehrere Funktionen (`_validate_start_end`, `shortest_path`, etc.)
   - **Beschreibung**: Fehlende oder unzureichende Docstrings bei wichtigen Funktionen.
   - **Empfehlung**: Konsistente Dokumentation für alle öffentlichen Funktionen und Klassen hinzufügen.

10. **Magic Numbers** 
    - **Pfad**: `build_sample_graph()` (Zeilen 82-90)
    - **Beschreibung**: Direkte Verwendung numerischer Konstanten ohne Benennung.
    - **Empfehlung**: Konstanten definieren oder zumindest Kommentare hinzufügen.

11. **Überflüssiger float-Cast** 
    - **Pfad**: `Graph.add_edge()` (Zeile 17)
    - **Beschreibung**: Redundanter Cast zu `float` bei `float(w)`, da bereits geprüft wird, ob `w` ein `int` oder `float` ist.
    - **Empfehlung**: Den expliziten Cast entfernen, wenn der Typ bereits validiert wurde.

12. **Zu viel Code in der `__main__`-Sektion** 
    - **Pfad**: `if __name__ == "__main__":`-Block
    - **Beschreibung**: Der Code sollte in eine separate Funktion ausgelagert werden.
    - **Empfehlung**: Eine `main()`-Funktion erstellen und von dort aufrufen.

#### Gering (2)

13. **Importierte aber nicht verwendete Module** 
    - **Beschreibung**: Nicht alle importierten Module werden verwendet.
    - **Empfehlung**: Nicht verwendete Importe entfernen.

14. **Lange Funktionen** 
    - **Pfad**: `dijkstra_naive()`
    - **Beschreibung**: Die Funktion ist mit über 50 Zeilen zu lang.
    - **Empfehlung**: In kleinere Funktionen aufteilen.

### Potential Bugs (3)

1. **Möglicher Pfad-Rekonstruktions-Bug** 
   - **Pfad**: `dijkstra_naive()` (Zeilen 79-85)
   - **Beschreibung**: Die Pfadrekonstruktion könnte bei zyklischen Graphen in eine Endlosschleife geraten.
   - **Empfehlung**: Eine zusätzliche Prüfung einbauen oder Iteration auf Anzahl der Knoten begrenzen.

2. **Fehlende Typprüfung für Knotenparameter** 
   - **Pfad**: `Graph.add_edge()`
   - **Beschreibung**: Während `w` auf Typkorrektheit geprüft wird, fehlt diese Prüfung für `u` und `v`.
   - **Empfehlung**: Konsistente Typprüfung für alle Parameter.

3. **Möglicher KeyError bei Knotenzugriff** 
   - **Pfad**: `dijkstra_naive()` (mehrere Stellen)
   - **Beschreibung**: Verschiedene Dictionary-Zugriffe ohne vorherige Existenzprüfung.
   - **Empfehlung**: Safer Dictionary-Zugriffe mit `.get()` oder try/except verwenden.

### Sicherheitsbedenken (1)

1. **Potenzielle Ressourcenerschöpfung** 
   - **Pfad**: `dijkstra_naive()`
   - **Beschreibung**: Bei sehr großen Graphen könnte der ineffiziente Algorithmus zu Speicher- oder CPU-Erschöpfung führen.
   - **Empfehlung**: Effizientere Datenstrukturen verwenden und Zeitkomplexität verbessern.

## Metriken

- **Zyklomatische Komplexität**: 24 (gesamt), 14 (max pro Funktion in `dijkstra_naive`)
- **Cognitive Complexity**: 18
- **Maintainability Index**: 37 (schlecht, < 65 gilt als schwer wartbar)
- **Testabdeckung**: 0% (keine Tests vorhanden)
- **Duplicated Lines**: ~15% (hauptsächlich durch wiederholte Validierungslogik)
- **Codezeilen**: ~100 (ohne Leerzeilen und Kommentare)

## Verbesserungsvorschläge

### Verbesserter Dijkstra-Algorithmus

```python
import heapq
from typing import Dict, List, Tuple, TypeVar, Generic, Optional

T = TypeVar('T')  # Generische Typvariable für Knotentypen
INF = float("inf")

class Graph(Generic[T]):
    def __init__(self) -> None:
        # adjacency list: node -> list[(neighbor, weight)]
        self.adj: Dict[T, List[Tuple[T, float]]] = {}

    def add_edge(self, u: T, v: T, w: float) -> None:
        if not isinstance(w, (int, float)) or w < 0:
            raise ValueError("Edge weight must be a non-negative number")
        self.adj.setdefault(u, []).append((v, w))
        self.adj.setdefault(v, [])  # ensure node exists

    def neighbors(self, u: T) -> List[Tuple[T, float]]:
        return self.adj.get(u, [])

def shortest_path(g: Graph[T], start: T, end: T) -> Tuple[float, List[T]]:
    """
    Find the shortest path from start to end in graph g.
    
    Args:
        g: The graph to search in
        start: Starting node
        end: Target node
        
    Returns:
        Tuple of (distance, path) where distance is the total distance and
        path is a list of nodes from start to end
        
    Raises:
        KeyError: If start or end node is not in the graph
    """
    if start not in g.adj:
        raise KeyError(f"Start node {start!r} not in graph")
    if end not in g.adj:
        raise KeyError(f"End node {end!r} not in graph")
    
    dist: Dict[T, float] = {u: INF for u in g.adj}
    prev: Dict[T, Optional[T]] = {}
    dist[start] = 0.0
    
    # Use heapq for efficient priority queue operations
    pq = [(0.0, start)]
    visited = set()
    
    while pq:
        d_u, u = heapq.heappop(pq)
        
        # Skip if we've found a better path already
        if u in visited:
            continue
            
        visited.add(u)
        
        if u == end:
            break
            
        for v, weight in g.neighbors(u):
            if v in visited:
                continue
                
            alt = d_u + weight
            if alt < dist.get(v, INF):
                dist[v] = alt
                prev[v] = u
                heapq.heappush(pq, (alt, v))
    
    # Reconstruct path with safety limit
    if dist.get(end, INF) == INF:
        return INF, []
        
    path: List[T] = []
    cur: Optional[T] = end
    max_path_length = len(g.adj)
    
    while cur is not None and len(path) <= max_path_length:
        path.append(cur)
        if cur == start:
            break
        cur = prev.get(cur)
        
    if cur != start and path:
        # Path reconstruction failed
        return INF, []
        
    path.reverse()
    return dist[end], path
```

## Fazit

Der Code enthält absichtlich eingebaute Ineffizienzen und Code Smells, wie in den Kommentaren erwähnt. Diese Probleme führen zu einer schlechten Wartbarkeit und potenziellen Fehleranfälligkeit. Die Hauptprobleme betreffen die ineffiziente Implementierung des Dijkstra-Algorithmus, die Vermischung von Verantwortlichkeiten und die Verletzung des DRY-Prinzips.

Die meisten Probleme können durch Refactoring und die Verwendung effizienter Datenstrukturen aus der Python-Standardbibliothek gelöst werden.